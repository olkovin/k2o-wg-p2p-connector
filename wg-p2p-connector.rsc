# ================================================================
# WireGuard P2P Connector v1.9
# Automated P2P WireGuard tunnel between two MikroTik routers
#
# Generated by k2o-wg-p2p-connector | https://k2o.cc
# GitHub: https://github.com/olkovin/k2o-wg-p2p-connector
# Made by t.me/olekovin with help of AI
# ================================================================
#
# Usage:
#   1. Edit CONFIGURATION section below
#   2. Upload the same configured script to BOTH routers
#   3. Run on Side1 (server) first: /import wg-p2p-connector.rsc
#   4. Run on Side2 (client) within 5 minutes
#
# ================================================================

# ================================================================
#  BASIC CONFIGURATION (required)
# ================================================================

# IP address of Side1 (will be server if has this IP locally)
:global p2pSide1Address "192.168.100.14"

# IP address of Side2 (empty string "" if behind NAT)
:global p2pSide2Address "192.168.100.15"

# Password for temporary SSTP key exchange (same on both routers!)
:global p2pSstpPass "TestPassword123!"

# ================================================================
#  MAIN CONFIGURATION (with defaults)
# ================================================================

# Short tunnel identifier (used in interface names)
:global p2pTunnelName "tunnel1"

# WireGuard IP addresses
:global p2pSide1WgIP "10.200.0.1"
:global p2pSide2WgIP "10.200.0.2"
:global p2pWgNetmask "/30"

# ================================================================
#  ADVANCED CONFIGURATION (optional)
# ================================================================

# WireGuard UDP port (on server)
:global p2pWgPort 51820

# SSTP TCP port for key exchange
:global p2pSstpPort 443

# SSTP username for key exchange
:global p2pSstpUser "p2p-k2o-exchange"

# Server wait timeout in seconds
:global p2pTimeout 300

# ================================================================
# DO NOT EDIT BELOW THIS LINE
# ================================================================

:local scriptVersion "1.9"

# Generate tunnel ID from timestamp
:local clockDate [/system clock get date]
:local clockTime [/system clock get time]
:local year [:pick $clockDate 0 4]
:local month [:pick $clockDate 5 7]
:local day [:pick $clockDate 8 10]
:local hour [:pick $clockTime 0 2]
:local minute [:pick $clockTime 3 5]
:local second [:pick $clockTime 6 8]
:local tunnelID ($year . $month . $day . $hour . $minute . $second)
:local timestamp ($day . "." . $month . "." . $year . " " . $clockTime)

# Comment marker for all entities
:local p2pComment ("Generated by k2o-wg-p2p-connector | k2o.cc | ID:" . $tunnelID . " | " . $timestamp)

:put ""
:put "================================================================"
:put ("  WireGuard P2P Connector v" . $scriptVersion)
:put "  https://k2o.cc"
:put "================================================================"

# ================================================================
# ROLE DETECTION
# ================================================================

:put ""
:put "[1/6] Detecting role..."

:local myRole ""
:local myWgIP ""
:local peerWgIP ""
:local peerAddress ""

# Check if we have Side1 address locally
:local hasSide1 false
:foreach addr in=[/ip address find] do={
    :local addrIP [/ip address get $addr address]
    :local addrOnly [:pick $addrIP 0 [:find $addrIP "/"]]
    :if ($addrOnly = $p2pSide1Address) do={
        :set hasSide1 true
    }
}

# Check if we have Side2 address locally
:local hasSide2 false
:if ([:len $p2pSide2Address] > 0) do={
    :foreach addr in=[/ip address find] do={
        :local addrIP [/ip address get $addr address]
        :local addrOnly [:pick $addrIP 0 [:find $addrIP "/"]]
        :if ($addrOnly = $p2pSide2Address) do={
            :set hasSide2 true
        }
    }
}

# Determine role
:if ($hasSide1) do={
    :set myRole "server"
    :set myWgIP $p2pSide1WgIP
    :set peerWgIP $p2pSide2WgIP
    :set peerAddress $p2pSide2Address
    :put ("   Role: SERVER (has Side1 address: " . $p2pSide1Address . ")")
} else={
    :if ([:len $p2pSide2Address] = 0) do={
        # Side2 is empty, we are client behind NAT
        :set myRole "client"
        :set myWgIP $p2pSide2WgIP
        :set peerWgIP $p2pSide1WgIP
        :set peerAddress $p2pSide1Address
        :put "   Role: CLIENT (Side2 address empty, behind NAT)"
    } else={
        :if ($hasSide2) do={
            # We have Side2 address, we are client
            :set myRole "client"
            :set myWgIP $p2pSide2WgIP
            :set peerWgIP $p2pSide1WgIP
            :set peerAddress $p2pSide1Address
            :put ("   Role: CLIENT (has Side2 address: " . $p2pSide2Address . ")")
        } else={
            :put "ERROR: This router has neither Side1 nor Side2 address!"
            :put ("   Side1: " . $p2pSide1Address)
            :put ("   Side2: " . $p2pSide2Address)
            :error "No matching IP address found"
        }
    }
}

:log warning ("P2P-WG: Starting as " . $myRole . " | ID:" . $tunnelID)

# ================================================================
# SINGLE ADOPTION CHECK (server only)
# ================================================================

:global p2pAdoptionActive
:global p2pAdoptionID
:global p2pAdoptionServerPubkey
:global p2pAdoptionServerPort
:global p2pReceivedClientPubkey

:if ($myRole = "server") do={
    :if ([:typeof $p2pAdoptionActive] != "nil" && $p2pAdoptionActive = true) do={
        :put ""
        :put "ERROR: Another adoption already in progress!"
        :put ("   Active adoption ID: " . $p2pAdoptionID)
        :put "   To cancel: /system script run p2p-k2o-cancel"
        :error "Adoption already active"
    }
    :set p2pAdoptionActive true
    :set p2pAdoptionID $tunnelID
}

# ================================================================
# CREATE WIREGUARD INTERFACE
# ================================================================

:put ""
:put "[2/6] Creating WireGuard interface..."

# Check for port conflicts (server only)
:local actualWgPort $p2pWgPort
:if ($myRole = "server") do={
    :local portInUse true
    :local maxPortCheck ($p2pWgPort + 100)
    :while ($portInUse && ($actualWgPort < $maxPortCheck)) do={
        :local existingWg [/interface wireguard find where listen-port=$actualWgPort]
        :if ([:len $existingWg] > 0) do={
            :local existingName [/interface wireguard get $existingWg name]
            :put ("   Port " . $actualWgPort . " already used by: " . $existingName)
            :set actualWgPort ($actualWgPort + 1)
        } else={
            :set portInUse false
        }
    }
    :if ($actualWgPort != $p2pWgPort) do={
        :put ("   Using available port: " . $actualWgPort)
    }
    :if ($portInUse) do={
        :put "ERROR: No available ports in range!"
        :set p2pAdoptionActive false
        :error "No available WireGuard ports"
    }
}

:local wgInterfaceName ("wg-p2p-k2o-" . $p2pTunnelName . "-" . $tunnelID)

# Remove existing interface with same name if exists
:do { /interface wireguard remove [find where name=$wgInterfaceName] } on-error={}
:delay 500ms

# Create WireGuard interface
:if ($myRole = "server") do={
    /interface wireguard add name=$wgInterfaceName listen-port=$actualWgPort mtu=1420 comment=$p2pComment
} else={
    # Client doesn't need listen-port, will use temp name first
    :set wgInterfaceName ("wg-p2p-k2o-" . $p2pTunnelName . "-temp")
    :do { /interface wireguard remove [find where name=$wgInterfaceName] } on-error={}
    :delay 500ms
    /interface wireguard add name=$wgInterfaceName mtu=1420 comment="temp"
}
:delay 1s

# Verify creation
:local wgVerify [/interface wireguard find where name=$wgInterfaceName]
:if ([:len $wgVerify] = 0) do={
    :put "ERROR: WireGuard interface creation failed!"
    :if ($myRole = "server") do={ :set p2pAdoptionActive false }
    :error "WireGuard creation failed"
}

# Get public key
:local myPubkey [/interface wireguard get $wgInterfaceName public-key]
:put ("   Interface: " . $wgInterfaceName)
:put ("   Public key: " . $myPubkey)

# Add IP address
/ip address add address=($myWgIP . $p2pWgNetmask) interface=$wgInterfaceName comment=$p2pComment
:log info ("P2P-WG: WireGuard IP: " . $myWgIP . $p2pWgNetmask)

:if ($myRole = "server") do={
    :set p2pAdoptionServerPubkey $myPubkey
    :set p2pAdoptionServerPort $actualWgPort
}

# ================================================================
# KEY EXCHANGE
# ================================================================

:put ""
:put "[3/6] Key exchange..."

:if ($myRole = "server") do={
    # === SERVER MODE ===
    :log info "P2P-WG: Starting SSTP server for key exchange"
    :put ("   Starting SSTP server on port " . $p2pSstpPort . "...")

    # Create temporary PPP profile
    :local profileName ("p2p-k2o-profile-" . $tunnelID)
    /ppp profile add name=$profileName local-address=10.254.254.1 remote-address=10.254.254.2 use-encryption=yes comment=$p2pComment

    # Create PPP secret
    :local secretName ("p2p-k2o-" . $tunnelID)
    /ppp secret add name=$p2pSstpUser password=$p2pSstpPass profile=$profileName comment=$p2pComment

    # Create temporary SSH user for key exchange (same password as SSTP)
    :local sshUserName ("p2p-ssh-" . $tunnelID)
    :do { /user remove [find where name=$p2pSstpUser] } on-error={}
    /user add name=$p2pSstpUser password=$p2pSstpPass group=full comment=$p2pComment

    # Enable SSTP server
    /interface sstp-server server set enabled=yes default-profile=$profileName port=$p2pSstpPort authentication=mschap2 certificate=none

    # Create registration script
    :local regScriptName ("p2p-k2o-register-" . $tunnelID)
    :local regSource ""
    :set regSource ($regSource . "# P2P Key Registration | ID:" . $tunnelID . "\r\n")
    :set regSource ($regSource . ":global p2pReceivedClientPubkey\r\n")
    :set regSource ($regSource . ":global p2pClientPubkeyInput\r\n")
    :set regSource ($regSource . ":global p2pAdoptionServerPubkey\r\n")
    :set regSource ($regSource . ":global p2pAdoptionServerPort\r\n")
    :set regSource ($regSource . ":global p2pAdoptionID\r\n")
    :set regSource ($regSource . ":if ([:typeof \$p2pClientPubkeyInput] != \"nil\" && [:len \$p2pClientPubkeyInput] > 40) do={\r\n")
    :set regSource ($regSource . "    :set p2pReceivedClientPubkey \$p2pClientPubkeyInput\r\n")
    :set regSource ($regSource . "    :put \"SERVER_PUBKEY:\$p2pAdoptionServerPubkey\"\r\n")
    :set regSource ($regSource . "    :put \"SERVER_PORT:\$p2pAdoptionServerPort\"\r\n")
    :set regSource ($regSource . "    :put \"TUNNEL_ID:\$p2pAdoptionID\"\r\n")
    :set regSource ($regSource . "    :put \"KEY_RECEIVED:OK\"\r\n")
    :set regSource ($regSource . "    :log warning (\"P2P-WG: Received client pubkey\")\r\n")
    :set regSource ($regSource . "} else={\r\n")
    :set regSource ($regSource . "    :put \"ERROR:No pubkey provided\"\r\n")
    :set regSource ($regSource . "}\r\n")

    /system script add name=$regScriptName source=$regSource policy=read,write,policy,test comment=$p2pComment

    # Remove old cancel/finalize scripts if exist
    :do { /system script remove [find where name="p2p-k2o-cancel"] } on-error={}
    :do { /system script remove [find where name="p2p-k2o-finalize"] } on-error={}

    # Create cancel script
    :local cancelSource ""
    :set cancelSource ($cancelSource . "# Cancel P2P adoption\r\n")
    :set cancelSource ($cancelSource . ":global p2pAdoptionActive false\r\n")
    :set cancelSource ($cancelSource . ":global p2pAdoptionID\r\n")
    :set cancelSource ($cancelSource . ":local tid \$p2pAdoptionID\r\n")
    :set cancelSource ($cancelSource . "/interface sstp-server server set enabled=no\r\n")
    :set cancelSource ($cancelSource . ":do { /ppp secret remove [find where comment~\"k2o-wg-p2p\"] } on-error={}\r\n")
    :set cancelSource ($cancelSource . ":do { /ppp profile remove [find where comment~\"k2o-wg-p2p\"] } on-error={}\r\n")
    :set cancelSource ($cancelSource . ":do { /user remove [find where name=\"" . $p2pSstpUser . "\"] } on-error={}\r\n")
    :set cancelSource ($cancelSource . ":do { /system script remove [find where name~\"p2p-k2o-register\"] } on-error={}\r\n")
    :set cancelSource ($cancelSource . ":do { /system script remove [find where name=\"p2p-k2o-cancel\"] } on-error={}\r\n")
    :set cancelSource ($cancelSource . ":do { /system script remove [find where name=\"p2p-k2o-finalize\"] } on-error={}\r\n")
    :set cancelSource ($cancelSource . ":put \"Adoption cancelled\"\r\n")

    /system script add name="p2p-k2o-cancel" source=$cancelSource policy=read,write,policy,test comment=$p2pComment

    # Create finalize script (for manual fallback)
    :local finalizeSource ""
    :set finalizeSource ($finalizeSource . "# Manual finalize for server\r\n")
    :set finalizeSource ($finalizeSource . ":global p2pClientPubkey\r\n")
    :set finalizeSource ($finalizeSource . ":global p2pReceivedClientPubkey\r\n")
    :set finalizeSource ($finalizeSource . ":if ([:typeof \$p2pClientPubkey] != \"nil\" && [:len \$p2pClientPubkey] > 40) do={\r\n")
    :set finalizeSource ($finalizeSource . "    :set p2pReceivedClientPubkey \$p2pClientPubkey\r\n")
    :set finalizeSource ($finalizeSource . "    :put \"Client pubkey set. Adoption will complete.\"\r\n")
    :set finalizeSource ($finalizeSource . "} else={\r\n")
    :set finalizeSource ($finalizeSource . "    :put \"ERROR: Set p2pClientPubkey first!\"\r\n")
    :set finalizeSource ($finalizeSource . "    :put \"Example: :global p2pClientPubkey \\\"ABC123...=\\\"\"\r\n")
    :set finalizeSource ($finalizeSource . "}\r\n")

    /system script add name="p2p-k2o-finalize" source=$finalizeSource policy=read,write,policy,test comment=$p2pComment

    :put "   SSTP server ready."
    :put ""
    :put "   >>> NOW RUN THE SCRIPT ON SIDE2 (CLIENT) <<<"
    :put ""
    :put ("   Waiting for client (" . ($p2pTimeout / 60) . " min timeout)...")
    :put ""
    :put "   Your public key (for manual exchange):"
    :put ("   " . $myPubkey)
    :put ""

    :log warning ("P2P-WG: Server pubkey: " . $myPubkey)

    # Wait for client
    :local maxWait $p2pTimeout
    :local waited 0
    :local keyReceived false

    :while ($waited < $maxWait && !$keyReceived) do={
        :delay 5s
        :set waited ($waited + 5)

        :if ([:typeof $p2pReceivedClientPubkey] != "nil" && [:len $p2pReceivedClientPubkey] > 40) do={
            :set keyReceived true
        }

        :if (!$keyReceived && ($waited % 30 = 0)) do={
            :put ("   Still waiting... " . (($maxWait - $waited) / 60) . " min left")
        }
    }

    :if (!$keyReceived) do={
        :put ""
        :put "================================================================"
        :put "  TIMEOUT - MANUAL KEY EXCHANGE REQUIRED"
        :put "================================================================"
        :put ""
        :put "  SERVER PUBLIC KEY:"
        :put ("  " . $myPubkey)
        :put ""
        :put "  When you have client's key, run:"
        :put "  :global p2pClientPubkey \"CLIENT_KEY_HERE\""
        :put "  /system script run p2p-k2o-finalize"
        :put ""
        :put "  To cancel: /system script run p2p-k2o-cancel"
        :put "================================================================"

        :log warning ("P2P-WG: Timeout. Manual exchange needed. Pubkey: " . $myPubkey)

        # Don't cleanup yet - leave for manual finalize
        :error "Timeout - use manual exchange"
    }

    :local clientPubkey $p2pReceivedClientPubkey
    :put "   Client key received!"

    # Cleanup SSTP
    :put ""
    :put "[4/6] Cleaning up SSTP..."
    :delay 2s
    /interface sstp-server server set enabled=no
    :do { /ppp secret remove [find where comment~$tunnelID] } on-error={}
    :do { /ppp profile remove [find where comment~$tunnelID] } on-error={}
    :do { /user remove [find where name=$p2pSstpUser] } on-error={}
    :do { /system script remove [find where name=$regScriptName] } on-error={}
    :do { /system script remove [find where name="p2p-k2o-cancel"] } on-error={}
    :do { /system script remove [find where name="p2p-k2o-finalize"] } on-error={}
    :put "   SSTP cleaned up"

    # Add peer
    :put ""
    :put "[5/6] Adding WireGuard peer..."
    :local peerName ("wg-p2p-k2o-peer-" . $tunnelID)
    /interface wireguard peers add interface=$wgInterfaceName name=$peerName public-key=$clientPubkey allowed-address=($peerWgIP . "/32") comment=$p2pComment
    :put ("   Peer added: " . $peerName)

    # Firewall
    :put ""
    :put "[6/6] Adding firewall rule..."
    :local dropRules [/ip firewall filter find where chain="input" action~"drop|reject" !disabled]
    :if ([:len $dropRules] > 0) do={
        :local firstDrop [:pick $dropRules 0]
        /ip firewall filter add chain=input protocol=udp dst-port=$actualWgPort action=accept comment=$p2pComment place-before=$firstDrop
        :put "   Firewall rule added (before first drop)"
    } else={
        /ip firewall filter add chain=input protocol=udp dst-port=$actualWgPort action=accept comment=$p2pComment
        :put "   Firewall rule added (at end of chain)"
    }

    :set p2pAdoptionActive false

} else={
    # === CLIENT MODE ===
    :log info "P2P-WG: Connecting to SSTP server"
    :put ("   Connecting to: " . $peerAddress . ":" . $p2pSstpPort)

    # Create SSTP client
    :local sstpClientName ("sstp-p2p-" . $tunnelID)
    /interface sstp-client add name=$sstpClientName connect-to=$peerAddress port=$p2pSstpPort user=$p2pSstpUser password=$p2pSstpPass profile=default-encryption authentication=mschap2 verify-server-certificate=no verify-server-address-from-certificate=no disabled=no comment=$p2pComment

    # Wait for connection
    :local maxWait 60
    :local waited 0
    :local connected false

    :while ($waited < $maxWait && !$connected) do={
        :delay 2s
        :set waited ($waited + 2)
        :do {
            :local sstpStatus [/interface sstp-client get $sstpClientName running]
            :if ($sstpStatus) do={
                :set connected true
            }
        } on-error={}
    }

    :if (!$connected) do={
        :put ""
        :put "================================================================"
        :put "  SSTP CONNECTION FAILED - MANUAL KEY EXCHANGE REQUIRED"
        :put "================================================================"
        :put ""
        :put "  CLIENT PUBLIC KEY:"
        :put ("  " . $myPubkey)
        :put ""
        :put "  1. Copy this key to SERVER"
        :put "  2. Get server's public key"
        :put "  3. Run on THIS router:"
        :put "     :global p2pServerPubkey \"SERVER_KEY_HERE\""
        :put "     :global p2pServerTunnelID \"SERVER_TUNNEL_ID\""
        :put "     /system script run p2p-k2o-finalize"
        :put "================================================================"

        :log warning ("P2P-WG: SSTP failed. Manual needed. Pubkey: " . $myPubkey)

        # Create finalize script for client
        :local finalizeSource ""
        :set finalizeSource ($finalizeSource . "# Manual finalize for client\r\n")
        :set finalizeSource ($finalizeSource . ":global p2pServerPubkey\r\n")
        :set finalizeSource ($finalizeSource . ":global p2pServerTunnelID\r\n")
        :set finalizeSource ($finalizeSource . ":if ([:typeof \$p2pServerPubkey] = \"nil\" || [:len \$p2pServerPubkey] < 40) do={\r\n")
        :set finalizeSource ($finalizeSource . "    :put \"ERROR: Set p2pServerPubkey first!\"\r\n")
        :set finalizeSource ($finalizeSource . "    :error \"Missing pubkey\"\r\n")
        :set finalizeSource ($finalizeSource . "}\r\n")
        :set finalizeSource ($finalizeSource . ":local tid \$p2pServerTunnelID\r\n")
        :set finalizeSource ($finalizeSource . ":if ([:typeof \$tid] = \"nil\") do={ :set tid \"manual\" }\r\n")
        :set finalizeSource ($finalizeSource . ":local wgIf \"wg-p2p-k2o-" . $p2pTunnelName . "-temp\"\r\n")
        :set finalizeSource ($finalizeSource . ":local newName (\"wg-p2p-k2o-" . $p2pTunnelName . "-\" . \$tid)\r\n")
        :set finalizeSource ($finalizeSource . ":local peerIP \"" . $peerWgIP . "\"\r\n")
        :set finalizeSource ($finalizeSource . ":local serverAddr \"" . $peerAddress . "\"\r\n")
        :set finalizeSource ($finalizeSource . ":global p2pServerPort\r\n")
        :set finalizeSource ($finalizeSource . ":local wgPort " . $p2pWgPort . "\r\n")
        :set finalizeSource ($finalizeSource . ":if ([:typeof \$p2pServerPort] != \"nil\") do={ :set wgPort \$p2pServerPort }\r\n")
        :set finalizeSource ($finalizeSource . ":local comment (\"Generated by k2o-wg-p2p-connector | k2o.cc | ID:\" . \$tid)\r\n")
        :set finalizeSource ($finalizeSource . ":local peerName (\"wg-p2p-k2o-peer-\" . \$tid)\r\n")
        :set finalizeSource ($finalizeSource . "/interface wireguard peers add interface=\$wgIf name=\$peerName public-key=\$p2pServerPubkey endpoint-address=\$serverAddr endpoint-port=\$wgPort allowed-address=(\$peerIP . \"/32\") persistent-keepalive=25s comment=\$comment\r\n")
        :set finalizeSource ($finalizeSource . "/interface wireguard set \$wgIf name=\$newName comment=\$comment\r\n")
        :set finalizeSource ($finalizeSource . "/ip address set [find where interface=\$wgIf] comment=\$comment\r\n")
        :set finalizeSource ($finalizeSource . ":put \"Tunnel finalized!\"\r\n")
        :set finalizeSource ($finalizeSource . ":do { /system script remove [find where name=\"p2p-k2o-finalize\"] } on-error={}\r\n")

        /system script add name="p2p-k2o-finalize" source=$finalizeSource policy=read,write,policy,test comment="temp"

        :do { /interface sstp-client remove $sstpClientName } on-error={}
        :error "SSTP failed - use manual exchange"
    }

    :put "   Connected!"
    :delay 2s

    # Exchange keys via SSH
    :put "   Exchanging keys..."
    :local serverPubkey ""
    :local serverTunnelID ""
    :local serverPort $p2pWgPort

    :do {
        # Find the registration script on server (it has server's tunnel ID, not ours)
        :local sshFindCmd "/system script print where name~\"p2p-k2o-register\""
        :local sshCmd (":global p2pClientPubkeyInput \"" . $myPubkey . "\"; :foreach s in=[/system script find where name~\"p2p-k2o-register\"] do={/system script run \$s}")

        # Execute via SSH using the temporary SSTP user over PPP tunnel
        /system ssh-exec address=10.254.254.1 user=$p2pSstpUser password=$p2pSstpPass command=$sshCmd output-to-file=("p2p-ssh-result-" . $tunnelID)
        :delay 3s

        :local resultFile [/file find where name~("p2p-ssh-result-" . $tunnelID)]
        :if ([:len $resultFile] > 0) do={
            :local fileContent [/file get $resultFile contents]

            # Parse SERVER_PUBKEY
            :local pubkeyStart [:find $fileContent "SERVER_PUBKEY:"]
            :if ([:typeof $pubkeyStart] = "num") do={
                :local keyStart ($pubkeyStart + 14)
                :local keyEnd [:find $fileContent "\n" $keyStart]
                :if ([:typeof $keyEnd] != "num") do={ :set keyEnd [:len $fileContent] }
                :set serverPubkey [:pick $fileContent $keyStart $keyEnd]
                # Trim CR
                :if ([:pick $serverPubkey ([:len $serverPubkey] - 1) [:len $serverPubkey]] = "\r") do={
                    :set serverPubkey [:pick $serverPubkey 0 ([:len $serverPubkey] - 1)]
                }
            }

            # Parse TUNNEL_ID
            :local idStart [:find $fileContent "TUNNEL_ID:"]
            :if ([:typeof $idStart] = "num") do={
                :local tidStart ($idStart + 10)
                :local tidEnd [:find $fileContent "\n" $tidStart]
                :if ([:typeof $tidEnd] != "num") do={ :set tidEnd [:len $fileContent] }
                :set serverTunnelID [:pick $fileContent $tidStart $tidEnd]
                :if ([:pick $serverTunnelID ([:len $serverTunnelID] - 1) [:len $serverTunnelID]] = "\r") do={
                    :set serverTunnelID [:pick $serverTunnelID 0 ([:len $serverTunnelID] - 1)]
                }
            }

            # Parse SERVER_PORT
            :local portStart [:find $fileContent "SERVER_PORT:"]
            :if ([:typeof $portStart] = "num") do={
                :local pStart ($portStart + 12)
                :local pEnd [:find $fileContent "\n" $pStart]
                :if ([:typeof $pEnd] != "num") do={ :set pEnd [:len $fileContent] }
                :local portStr [:pick $fileContent $pStart $pEnd]
                :if ([:pick $portStr ([:len $portStr] - 1) [:len $portStr]] = "\r") do={
                    :set portStr [:pick $portStr 0 ([:len $portStr] - 1)]
                }
                :set serverPort [:tonum $portStr]
            }

            /file remove $resultFile
        }
    } on-error={
        :log warning "P2P-WG: SSH exec failed, trying fallback"
    }

    # Disconnect SSTP
    :put ""
    :put "[4/6] Disconnecting SSTP..."
    :do { /interface sstp-client remove $sstpClientName } on-error={}
    :put "   Disconnected"

    :if ([:len $serverPubkey] < 40) do={
        :put ""
        :put "================================================================"
        :put "  KEY EXCHANGE FAILED - MANUAL EXCHANGE REQUIRED"
        :put "================================================================"
        :put ""
        :put "  CLIENT PUBLIC KEY:"
        :put ("  " . $myPubkey)
        :put ""
        :put "  1. Copy this key to SERVER"
        :put "  2. Get server's public key, tunnel ID, and port"
        :put "  3. Run on THIS router:"
        :put "     :global p2pServerPubkey \"SERVER_KEY_HERE\""
        :put "     :global p2pServerTunnelID \"SERVER_TUNNEL_ID\""
        :put "     :global p2pServerPort SERVER_PORT  # if different from default"
        :put "     /system script run p2p-k2o-finalize"
        :put "================================================================"

        :log warning ("P2P-WG: Key exchange failed. Pubkey: " . $myPubkey)
        :error "Key exchange failed - use manual"
    }

    :put ("   Server pubkey received!")
    :put ("   Server tunnel ID: " . $serverTunnelID)

    # Use server's tunnel ID
    :set tunnelID $serverTunnelID
    :set p2pComment ("Generated by k2o-wg-p2p-connector | k2o.cc | ID:" . $tunnelID . " | " . $timestamp)

    # Rename interface
    :local newWgName ("wg-p2p-k2o-" . $p2pTunnelName . "-" . $tunnelID)
    /interface wireguard set $wgInterfaceName name=$newWgName comment=$p2pComment
    :set wgInterfaceName $newWgName
    /ip address set [find where interface=$wgInterfaceName] comment=$p2pComment

    # Add peer
    :put ""
    :put "[5/6] Adding WireGuard peer..."
    :local peerName ("wg-p2p-k2o-peer-" . $tunnelID)
    /interface wireguard peers add interface=$wgInterfaceName name=$peerName public-key=$serverPubkey endpoint-address=$peerAddress endpoint-port=$serverPort allowed-address=($peerWgIP . "/32") persistent-keepalive=25s comment=$p2pComment
    :put ("   Peer added: " . $peerName)
    :if ($serverPort != $p2pWgPort) do={
        :put ("   Note: Server uses port " . $serverPort . " (auto-assigned)")
    }

    :put ""
    :put "[6/6] Skipping firewall (client mode)"
}

# ================================================================
# GENERATE REMOVE SCRIPT
# ================================================================

:put ""
:put "Generating removal script..."

:local removeScriptName ("remove-p2p-k2o-" . $tunnelID)
:local removeSource ""
:set removeSource ($removeSource . "# WireGuard P2P Tunnel Removal\r\n")
:set removeSource ($removeSource . "# Tunnel ID: " . $tunnelID . "\r\n")
:set removeSource ($removeSource . "# Generated by k2o-wg-p2p-connector | k2o.cc\r\n")
:set removeSource ($removeSource . "\r\n")
:set removeSource ($removeSource . ":local tid \"" . $tunnelID . "\"\r\n")
:set removeSource ($removeSource . ":local marker (\"ID:\" . \$tid)\r\n")
:set removeSource ($removeSource . ":put (\"Removing P2P tunnel: \" . \$tid)\r\n")
:set removeSource ($removeSource . ":log warning (\"P2P-WG: Removing tunnel \" . \$tid)\r\n")
:set removeSource ($removeSource . "\r\n")
:set removeSource ($removeSource . ":do { /interface wireguard peers remove [find where comment~\$marker] } on-error={}\r\n")
:set removeSource ($removeSource . ":do { /ip address remove [find where comment~\$marker] } on-error={}\r\n")
:set removeSource ($removeSource . ":do { /ip firewall filter remove [find where comment~\$marker] } on-error={}\r\n")
:set removeSource ($removeSource . ":do { /ip route remove [find where comment~\$marker] } on-error={}\r\n")
:set removeSource ($removeSource . ":do { /interface wireguard remove [find where comment~\$marker] } on-error={}\r\n")
:set removeSource ($removeSource . ":do { /system script remove [find where comment~\$marker] } on-error={}\r\n")
:set removeSource ($removeSource . "\r\n")
:set removeSource ($removeSource . ":put (\"Tunnel \" . \$tid . \" removed!\")\r\n")
:set removeSource ($removeSource . ":log warning (\"P2P-WG: Tunnel \" . \$tid . \" removed\")\r\n")

/system script add name=$removeScriptName source=$removeSource policy=read,write comment=$p2pComment

# ================================================================
# COMPLETE
# ================================================================

:put ""
:put "================================================================"
:put "  DEPLOYMENT COMPLETE!"
:put "================================================================"
:put ""
:put ("  Tunnel ID: " . $tunnelID)
:put ("  Interface: " . $wgInterfaceName)
:put ("  Local IP: " . $myWgIP)
:put ("  Peer IP: " . $peerWgIP)
:put ""
:put ("  Test: /ping " . $peerWgIP)
:put ""
:put ("  Remove: /system script run " . $removeScriptName)
:put ""
:put "================================================================"
:put "  Generated by k2o-wg-p2p-connector | https://k2o.cc"
:put "================================================================"

:log warning ("P2P-WG: Complete! ID:" . $tunnelID . " | Test: ping " . $peerWgIP)

# Cleanup globals
:do { /system script environment remove [find where name~"p2p"] } on-error={}
