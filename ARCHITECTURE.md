# Architecture

Technical design document for k2o-wg-p2p-connector.

## Design Goals

1. **Single script** — same file works on both routers
2. **Automatic role detection** — based on IP addresses
3. **Automatic key exchange** — no manual intervention required
4. **Port conflict detection** — auto-finds available port if default is busy
5. **One adoption at a time** — server handles only one pending connection
6. **Safe removal** — requires 3 confirmations within 30 seconds
7. **Clean removal** — all entities can be removed by tunnel ID
8. **Fallback to manual** — if automation fails, show instructions

## Role Detection Logic

```mermaid
flowchart LR
    A[Script Start] --> B{Has Side1Address<br/>on local interface?}
    B -->|Yes| C[Role = Server]
    B -->|No| D{Side2Address empty?}
    D -->|Yes| E[Role = Client]
    D -->|No| F{Has Side2Address<br/>on local interface?}
    F -->|Yes| G{Side1 reachable?}
    F -->|No| H[ERROR: No matching IP]
    G -->|Yes, SSTP active| I[Role = Client]
    G -->|No| J[Role = Server]
```

## Configuration Structure

```routeros
# ═══════════════════════════════════════════════════════════════════
#  BASIC CONFIGURATION (required)
# ═══════════════════════════════════════════════════════════════════

:global p2pSide1Address "1.2.3.4"          # Public IP/FQDN of Side1
:global p2pSide2Address "5.6.7.8"          # Public IP of Side2 (empty if NAT)
:global p2pSstpPass "ChangeThisPassword!"  # Key exchange password

# ═══════════════════════════════════════════════════════════════════
#  MAIN CONFIGURATION (with defaults)
# ═══════════════════════════════════════════════════════════════════

:global p2pTunnelName "tunnel1"            # Short tunnel identifier
:global p2pSide1WgIP "10.200.0.1"          # Side1 WG IP
:global p2pSide2WgIP "10.200.0.2"          # Side2 WG IP
:global p2pWgNetmask "/30"                 # Network mask

# ═══════════════════════════════════════════════════════════════════
#  ADVANCED CONFIGURATION (optional)
# ═══════════════════════════════════════════════════════════════════

:global p2pWgPort 51820                    # WireGuard UDP port
:global p2pSstpPort 443                    # SSTP TCP port
:global p2pSstpUser "p2p-k2o-exchange"     # SSTP username
:global p2pTimeout 300                     # Timeout (seconds)
```

## Naming Convention

| Entity | Pattern | Example |
|--------|---------|---------|
| WG Interface | `wg-p2p-k2o-{name}-{id}` | `wg-p2p-k2o-office-20251206173000` |
| WG Peer | `wg-p2p-k2o-peer-{id}` | `wg-p2p-k2o-peer-20251206173000` |
| Remove script | `remove-p2p-k2o-{id}` | `remove-p2p-k2o-20251206173000` |
| Finalize script | `p2p-k2o-finalize` | (no ID, only one at a time) |
| Cancel script | `p2p-k2o-cancel` | (no ID, only one at a time) |
| PPP secret (temp) | `p2p-k2o-{id}` | `p2p-k2o-20251206173000` |
| PPP profile (temp) | `p2p-k2o-profile-{id}` | `p2p-k2o-profile-20251206173000` |
| Register script (temp) | `p2p-k2o-register-{id}` | `p2p-k2o-register-20251206173000` |

## Comment Marker

All created entities have this comment format:

```
Generated by k2o-wg-p2p-connector | k2o.cc | ID:20251206173000 | 06.12.2025 17:30:00
```

## Tunnel ID Format

```
YYYYMMDDHHMMSS
```

Example: `20251206173000` = 2025-12-06 17:30:00

- Generated on **server** at adoption start
- Synchronized to **client** during SSTP key exchange
- Used to identify all entities for removal

## Key Exchange Flow

```mermaid
sequenceDiagram
    participant S as Side1 (Server)
    participant C as Side2 (Client)

    rect rgb(200, 220, 255)
        Note over S: INITIALIZATION
        S->>S: Generate Tunnel ID
        S->>S: Check port conflicts
        S->>S: Create WG interface
        S->>S: Get public key
        S->>S: Start SSTP server
        S->>S: Create register script
    end

    S-->>S: Waiting for client (5 min)...

    rect rgb(220, 255, 220)
        Note over C: INITIALIZATION
        C->>C: Create WG interface
        C->>C: Get public key
    end

    rect rgb(255, 240, 200)
        Note over S,C: KEY EXCHANGE
        C->>S: Connect via SSTP
        C->>S: SSH: send client pubkey
        S->>C: Return: pubkey + ID + port
    end

    rect rgb(255, 220, 220)
        Note over S: FINALIZATION
        S->>S: Add WG peer
        S->>S: Add firewall rule (with actual port)
        S->>S: Stop SSTP server
        S->>S: Cleanup temp entities
        S->>S: Generate remove script
    end

    rect rgb(255, 220, 220)
        Note over C: FINALIZATION
        C->>C: Disconnect SSTP
        C->>C: Add WG peer (with endpoint + port)
        C->>C: Rename interface with ID
        C->>C: Generate remove script
    end

    Note over S,C: ✅ WireGuard tunnel active!
```

## Single Adoption Mechanism

Only one adoption process can be active on server at a time.

```routeros
# Global state variables (server only)
:global p2pAdoptionActive false
:global p2pAdoptionID ""
:global p2pAdoptionServerPubkey ""
:global p2pAdoptionServerPort

# Check before starting new adoption
:if ($p2pAdoptionActive) do={
    :put "ERROR: Another adoption in progress (ID: $p2pAdoptionID)"
    :put "Run: /system script run p2p-k2o-cancel"
    :error "Adoption already active"
}

# Set active
:set p2pAdoptionActive true
:set p2pAdoptionID $tunnelID
:set p2pAdoptionServerPubkey $myPubkey
:set p2pAdoptionServerPort $actualWgPort

# Clear on completion/timeout/cancel
:set p2pAdoptionActive false
```

## Port Conflict Detection

Server automatically finds available port if default is in use:

```mermaid
flowchart LR
    A[Check port 51820] --> B{In use?}
    B -->|No| C[Use 51820]
    B -->|Yes| D[Try 51821]
    D --> E{In use?}
    E -->|No| F[Use 51821]
    E -->|Yes| G[Try next...]
    G --> H[Up to +100]
```

```routeros
:local actualWgPort $p2pWgPort
:local portInUse true
:while ($portInUse && ($actualWgPort < ($p2pWgPort + 100))) do={
    :local existingWg [/interface wireguard find where listen-port=$actualWgPort]
    :if ([:len $existingWg] > 0) do={
        :put ("Port $actualWgPort already used by: " . [/interface wireguard get $existingWg name])
        :set actualWgPort ($actualWgPort + 1)
    } else={
        :set portInUse false
    }
}
```

## Firewall Integration

Server automatically adds WireGuard accept rule before first drop:

```mermaid
flowchart LR
    A[Find first DROP<br/>in input chain] --> B{Found?}
    B -->|Yes| C[Add ACCEPT UDP<br/>before DROP]
    B -->|No| D[Add ACCEPT UDP<br/>at end of chain]
```

```routeros
:local dropRules [/ip firewall filter find where chain="input" action~"drop|reject" !disabled]
:if ([:len $dropRules] > 0) do={
    :local firstDrop [:pick $dropRules 0]
    /ip firewall filter add \
        chain=input protocol=udp dst-port=$actualWgPort \
        action=accept comment=$p2pComment place-before=$firstDrop
}
```

## Manual Fallback

If automatic key exchange fails:

### On Server

```
═══════════════════════════════════════════════════════════════════
  MANUAL KEY EXCHANGE
═══════════════════════════════════════════════════════════════════

  SERVER PUBLIC KEY:
  +ABC123...XYZ=

  Waiting for client public key...

  When you have client's key, run:
  :global p2pClientPubkey "+CLIENT_KEY_HERE="
  /system script run p2p-k2o-finalize
═══════════════════════════════════════════════════════════════════
```

### On Client

```
═══════════════════════════════════════════════════════════════════
  MANUAL KEY EXCHANGE
═══════════════════════════════════════════════════════════════════

  CLIENT PUBLIC KEY:
  +DEF456...ABC=

  1. Copy this key to SERVER router
  2. Get server's public key
  3. On THIS router run:
     :global p2pServerPubkey "+SERVER_KEY_HERE="
     /system script run p2p-k2o-finalize
═══════════════════════════════════════════════════════════════════
```

## Remove Script

Generated on both server and client with **safety confirmation**:

```
==================================================
  REMOVAL CONFIRMATION REQUIRED
==================================================
  Tunnel ID: 20251209123456

  Run this script 2 more time(s)
  within 30 seconds to confirm removal.
==================================================
```

The script requires **3 executions within 30 seconds** to actually perform the removal. This prevents accidental tunnel deletion.

```routeros
# remove-p2p-k2o-{id}
# Safety: Run 3 times within 30 seconds to confirm removal

:global p2pRemoveConfirm{id}
:global p2pRemoveTime{id}

# Check if confirmation expired (30 sec)
:if (elapsed > 30) do={ :set p2pRemoveConfirm{id} 0 }

# Increment counter
:set p2pRemoveConfirm{id} ($p2pRemoveConfirm{id} + 1)

# Need 3 confirmations
:if ($p2pRemoveConfirm{id} < 3) do={
    :put "Run $remaining more time(s) within 30 seconds"
    :error "Confirmation required"
}

# Actually remove (on 3rd run)
:do { /interface wireguard peers remove [find where comment~$marker] } on-error={}
:do { /ip address remove [find where comment~$marker] } on-error={}
:do { /ip firewall filter remove [find where comment~$marker] } on-error={}
:do { /ip route remove [find where comment~$marker] } on-error={}
:do { /interface wireguard remove [find where comment~$marker] } on-error={}
:do { /system script remove [find where comment~$marker] } on-error={}

:put "Tunnel $tunnelID removed!"
```

## Error Handling

| Error | Server Action | Client Action |
|-------|--------------|---------------|
| Adoption already active | Show error, suggest cancel | N/A |
| SSTP connection failed | N/A | Show manual exchange |
| SSH execution failed | N/A | Show manual exchange |
| Key exchange timeout | Cleanup, show manual | Show manual exchange |
| WG interface creation failed | Fatal error | Fatal error |

## File Structure

```
k2o-wg-p2p-connector/
├── README.md              # English documentation
├── README.uk.md           # Ukrainian documentation
├── ARCHITECTURE.md        # This file
├── wg-p2p-connector.rsc   # Main script
├── LICENSE                # MIT License
└── .gitignore
```
